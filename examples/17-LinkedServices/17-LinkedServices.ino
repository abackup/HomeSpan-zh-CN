/*********************************************************************************
 *  MIT 许可证
 *  
 *  Copyright (c) 2020-2024 Gregg E. Berman
 *  
 *  https://github.com/HomeSpan/HomeSpan
 *  
 *  特此授予获得此软件和相关文档文件（“软件”）副本的任何人免费许可，以无限制方式处理软件，
 *  包括但不限于使用、复制、修改、合并、发布、分发、再许可和/或销售软件副本的权利，并允许
 *  向其提供软件的人员这样做，但须遵守以下条件：
 *  
 *  上述版权声明和本许可声明均应包含在软件的所有副本或重要部分中。
 *  
 *  软件按“原样”提供，不作任何明示或暗示的保证，包括但不限于适销性、特定用途的适用性和不
 *  侵权性的保证。在任何情况下，作者或版权持有者均不对因软件或使用或其他处理软件而引起的
 *  或与之相关的任何索赔、损害或其他责任承担责任，无论是合同行为、侵权行为还是其他行为。
 *  
 ********************************************************************************/
 
////////////////////////////////////////////////////////////
//                                                        //
//              HomeSpan：ESP32 的 HomeKit 实现           //
//    ------------------------------------------------    //
//                                                        //
//           示例 17：链接服务                             //
//                   * 实现多头水疗淋浴                    //
//                                                        //
////////////////////////////////////////////////////////////

#include "HomeSpan.h" 

  // HAP 通常将同一附件内创建的多个服务视为彼此独立的。但是，某些 HAP 服务旨在代表对其他更典型服务的中央控制点。
  // 例如，您可以创建一个具有一个或多个阀门服务的附件，每个阀门服务都独立运行。但 HAP 还包括一个水龙头服务，
  // 可用于“控制”一个或多个阀门服务。这是通过将水龙头服务链接到一个或多个阀门服务来实现的。

  // 只有少数类型的 HAP 服务允许/要求链接到其他服务，并且只有少数类型的服务可以选择作为链接。

  // 可以使用 addLink() 方法在 HomeSpan 中创建链接服务。例如，如果 spaShower 是指向水龙头服务的指针，
  // 而 showerHead 和 handSprayer 都是指向阀门服务的指针，则可以按如下方式将水龙头链接到阀门：

  // spaShower->addLink(showerHead);
  // spaShower->addLink(handSprayer);

  // addLink 方法返回一个指向调用它的对象的指针，它为您提供了将上述两种方法组合成一行的选项，如下所示：

  // spaShower->addLink(showerHead)->addLink(handSprayer);

  // 请注意，HAP 不提供“控制”服务操作“链接”服务所需的任何实际逻辑。这仍然必须由用户编程。更重要的是，
  // 逻辑需要符合 HAP 期望的服务行为，如 HAP 文档中对控制服务所述。除了让您做额外的工作之外，HAP 对链接服务真正做的唯一
  // 事情是提供一个自定义的图块，向您显示控制服务及其链接到的服务。

  // 同样如上所述，只有少数服务支持链接服务协议。如果您将 addLink() 方法与不支持链接的服务一起使用，HAP 将忽略链接请求。
  // 但反之则不然。如果您实施的服务需要其他链接服务（例如水龙头），则必须创建这些链接才能使服务正常运行。
  // 下面的示例 17 通过使用一个 HAP 水龙头服务和多个 HAP 阀门服务实施多头水疗淋浴来演示链接服务。像往常一样，我们将从
  // HAP 的水龙头和阀门服务创建我们自己的“子”服务，以便我们可以添加实施设备所需的逻辑。但是，我们不会将所有逻辑放在单
  // 独的 *.h 文件中，而是将它们直接包含在主草图文件中（如下所示），以说明组织草图代码的另一种方式。

  // 此示例进一步说明了另一种编码样式选项：我们不会在草图的 setup() 部分中实例化所需的所有服务，而是仅实例化淋浴服务，
  // 并让淋浴服务本身实例化所有阀门服务。事实上，我们对价值服务的整个定义完全封装在淋浴服务的定义中。
  // 希望这能为 HomeSpan 的灵活性提供一个很好的例子。由于所有 HomeSpan 组件都是使用标准 C++ 结构定义的（而不是基于某些
  // 预定义格式的外部文件），因此您可以选择任何您喜欢的编码风格。之所以选择下面的风格，是因为它似乎非常适合说明链接服务的工作原理。
  // 但请注意，只有 addLink() 方法才能创建实际的链接。WaterValve 服务是在 Shower 服务中定义的，这纯粹是一种风格选择，它本身并不创建链接。
  // 我们可以为 WaterValve 定义使用独立的结构，结果是一样的。

//////////////////////////////////////

  // HAP 阀门服务需要活动特性和使用中特性。活动特性控制阀门是打开（活动）还是关闭（非活动）。此特性通常由用户通过 “家庭”应用控制。
  // 使用中特性指定是否有水（或气体等）实际流过阀门。这是因为打开阀门并不一定意味着水会流动。可能还有另一个现实世界的“主”阀门也需要打开，
  // 水才能开始流动。或者可能有另一个服务也必须处于活动状态才能使水流过阀门。因此，如果阀门打开，则使用中特性可以是真或假，但只有阀门关闭
  // 时才可以是假。“家庭”应用无法更改使用中特性。它只能由 “家庭”应用读取为状态。
  // 可以创建一个多阀门配件，其中每个阀门都由 “家庭”应用独立控制，HomeSpan 使用内部逻辑根据打开或关闭的阀门组合确定哪些阀门有水流（InUse=true）
  // 以及哪些没有（InUse=false）。

  // HAP 水龙头服务用于为与其链接的所有阀门创建“中央控制开关”。“家庭”应用将每个阀门显示为水龙头控制页面上的小图标。单击阀门图标可切换其打开/关闭，
  // 并相应地更改图标。但是，除非淋浴控制开关本身也打开，否则水不会流动。因此，实现 HAP 水龙头需要编码的逻辑是，仅当阀门打开且淋浴打开时，才将阀门
  // 的 InUse 特性设置为 true。如果淋浴关闭，阀门保持打开状态，但需要将 InUse 特性重置为 false。同样，如果淋浴器重新打开，则需要将每个打开的阀门
  // 的 InUse 特性设置为 true。这模仿了带有中央控制开关的实际淋浴器的操作方式。

  // 此外，当您操作淋浴器和阀门控件时，“家庭”应用会显示 4 种状态消息之一：

  // 关闭：淋浴开关关闭，并且每个阀门的 InUse 特性设置为 FALSE（任何地方都没有水流出）；停止：淋浴开关关闭，但至少一个阀门的 InUse 特性仍设置为 TRUE。
  // 据推测这意味着阀门正在关闭；启动：淋浴开关打开，但每个阀门的 InUse 特性设置为 FALSE。这表示淋浴正在等待水开始流动；运行：淋浴开关打开，并且至少
  // 一个阀门的 InUse 特性设置为 TRUE。这表示水正在流动。

  // 请注意，淋浴服务仅监控其链接阀门的使用特性。它不监控链接阀门的活动特性。此外，打开和关闭淋浴开关不应改变任何阀门的活动特性。以下是实现所有这些 HAP 所需逻辑的代码：
  
struct Shower : Service::Faucet {                 // 这是我们的 Shower 结构，我们将其定义为 HomeSpan Faucet 结构的子类

  SpanCharacteristic *active=new Characteristic::Active();     // 我们的实现只需要 Active Characteristic

  Shower(int nHeads){                   // 这是 Shower 的构造函数。它采用一个参数来指定喷头的数量 (WaterValves)
    for(int i=0;i<nHeads;i++)           // 每个喷头都需要 ---
      addLink(new WaterValve(this));    // --- 实例化一个新的 WaterValve 并将其链接到 Shower。此外，将 Shower 对象的指针传递给 WaterValve 构造函数。我们将在下面看到原因。
  }
  
  struct WaterValve : Service::Valve {                            // 在这里我们将 WaterValve 结构定义为 HomeSpan Valve Service 的子类
    SpanCharacteristic *active=new Characteristic::Active(1);;    // 活动特性用于指定阀门是活动（打开）还是非活动（关闭）
    SpanCharacteristic *inUse=new Characteristic::InUse();        // InUser 特性用于指定水是否实际流过值
    Shower *shower;                                               // 存储指向“控制”淋浴服务的指针
    
    WaterValve(Shower *s){                                                      // 这是 WaterValve 的构造函数。它接受一个指向“控制”淋浴服务的参数
      shower=s;                                                                 // 将指针存储到淋浴服务
      new Characteristic::ValveType(Characteristic::ValveType::SHOWER_HEAD);    // 将阀门类型指定为淋浴喷头（注意使用常量“Characteristic::ValveType::SHOWER_HEAD”）
    }
    
    boolean update() override {                                   // 每当 “家庭”应用请求更改 Valve 的活动特性时，HomeSpan 都会调用此方法
      if(shower->active->getVal())                                // 这里我们使用指向 Shower 的指针：仅当 Shower 对象本身处于活动状态时---
        inUse->setVal(active->getNewVal());                       // --- 我们是否更新 InUse 特征来反映流水状态的变化。
      return(true);                                               // 请注意，无论淋浴状态如何，阀门本身仍会从活动状态变为非活动状态（反之亦然）
    }
    
    void loop() override {                                                    // 在这里我们检查淋浴是打开还是关闭，并确定这是否意味着我们需要更新阀门
      if(shower->active->getVal() && active->getVal() && !inUse->getVal())    // 如果淋浴处于活动状态，并且阀门处于活动状态但未显示正在使用...
        inUse->setVal(1);                                                     // ...显示阀门正在使用中
      else if(!shower->active->getVal() && inUse->getVal())                   // 否则，如果淋浴未处于活动状态但阀门显示正在使用中...
        inUse->setVal(0);                                                     // ...显示阀门未在使用中
    }

  }; // 水阀
};

//////////////////////////////////////

void setup() {

  Serial.begin(115200);
  
  homeSpan.begin(Category::ShowerSystems,"HomeSpan Shower");

  new SpanAccessory();  
    new Service::AccessoryInformation();
      new Characteristic::Identify();                    
    
    new Shower(4);                                          // 打造一个配有 4 个喷头的水疗淋浴

} // setup() 结束

//////////////////////////////////////

void loop(){
  
  homeSpan.poll();
  
} // loop() 结束

//////////////////////////////////////
